<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Example D3 Charts</title>
        <style>

        #everthang {
          border: 2px solid black;
          border-radius: 3px;
        }

        .bar {
          fill: olive;
        }
        
        text {
          fill: darkgrey;
        }

        .bar:hover {
          fill: orange;
        }

        .axis--x path {
          display: none;
        }

        </style>
        <link rel="stylesheet" href="style.css"></link>
    </head>
    <body>
        <select onchange="chart(this.value)">
            <option value="Choose a visualization." selected disabled>Choose a chart.</option>
            <option value="histogram">histogram</option>
            <option value="scatterplot">scatterplot</option>
            <option value="parallel-axes">parallel-axes</option>
        </select>
        <div id="vis-container"></div>
        <svg id="histogram" width="960" height="500"></svg>
        <script src="https://bl.ocks.org/syntagmatic/raw/3341641/render-queue.js"></script>
        <script src="./d3.v4.min.js"></script>
        <script>

          /* assign data-literal to plot */
          var width = 420;
          var data = [ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 600, 977, 1577, 2454, 4031, 6485];
          var x = d3.scaleLinear()
              .domain(d3.extent(data, function(d) { return d; }));
          console.log({width, data, x});

          /* recreate deprecated d3 functionality lost b4 v4: d3.rebind */
          // Copies a variable number of methods from source to target.
          d3.rebind = function(target, source) {
            var i = 1, n = arguments.length, method;
            while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
            return target;
          };

          // Method is assumed to be a standard D3 getter-setter:
          // If passed with no arguments, gets the value.
          // If passed with arguments, sets the value and returns the target.
          function d3_rebind(target, source, method) {
            return function() {
              var value = method.apply(source, arguments);
              return value === source ? target : value;
            };
          }

          d3.functor = function(v) {
            return typeof v === "function" ? v : function() { return v; };
          };

        function chart(chartType) {
            d3.select('#vis-container').selectAll('*').remove();//remove scatterplot
            d3.select('#histogram').selectAll('*').remove();//remove histogram
            d3.select('#histogram').style('display', 'none');

            // ############# histogram ###############
            if (chartType === 'histogram') {
                /* create random distribution to plot */
                var randomData = d3.range(1000).map(d3.randomBates(10));

                var formatCount = d3.format(",.0f");

                var svg = d3.select("svg"),
                    margin = {top: 10, right: 30, bottom: 30, left: 30},
                    width = +svg.attr("width") - margin.left - margin.right,
                    height = +svg.attr("height") - margin.top - margin.bottom,
                    g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

                var x = d3.scaleLinear()
                    .domain(d3.extent(data))
                    .rangeRound([0, width]);

                var bins = d3.histogram()
                    .domain(x.domain())
                    .thresholds(x.ticks(10))
                    (data);

                var y = d3.scaleLinear()
                    .domain([0, d3.max(bins, function(d) { return d.length; })])
                    .range([height, 0]);

                var bar = g.selectAll(".bar")
                  .data(bins)
                  .enter().append("g")
                    .attr("class", "bar")
                    .attr("transform", function(d) { return "translate(" + x(d.x0) + "," + y(d.length) + ")"; });

                d3.select('#histogram').style('display', 'block');

                bar.append("rect")
                    .attr("x", 1)
                    .attr("width", x(bins[0].x1) - x(bins[0].x0) - 1)
                    .attr("height", function(d) { return height - y(d.length); });

                bar.append("text")
                    .attr("dy", ".75em")
                    .attr("y", 6)
                    .attr("x", (x(bins[0].x1) - x(bins[0].x0)) / 2)
                    .attr("text-anchor", "middle")
                    .text(function(d) { return formatCount(d.length); });

                g.append("g")
                    .attr("class", "axis axis--x")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x));
            }

            // ############## scatterplot ##################
            if (chartType === 'scatterplot') {
								// generate random data
								const data = d3.range(50).map((d, i) => ({
									x: Math.random(),
									y: Math.random(),
									id: i,
									label: `Point ${i}`,
								}));

								// ----------------------------------------------------
								// Build a basic scatterplot
								// ----------------------------------------------------

								// outer svg dimensions
								const width = 600;
								const height = 400;

								// padding around the chart where axes will go
								const padding = {
									top: 20,
									right: 20,
									bottom: 40,
									left: 50,
								};

								// inner chart dimensions, where the dots are plotted
								const plotAreaWidth = width - padding.left - padding.right;
								const plotAreaHeight = height - padding.top - padding.bottom;

								// radius of points in the scatterplot
								const pointRadius = 3;

								// initialize scales
								const xScale = d3.scaleLinear().domain([0, 1]).range([0, plotAreaWidth]);
								const yScale = d3.scaleLinear().domain([0, 1]).range([plotAreaHeight, 0]);
								const colorScale = d3.scaleLinear().domain([0, 1]).range(['#06a', '#0bb']);

								// select the root container where the chart will be added
								const container = d3.select('#vis-container');

								// initialize main SVG
								const svg = container.append('svg')
									.attr('width', width)
									.attr('height', height);

								// the main <g> where all the chart content goes inside
								const g = svg.append('g')
									.attr('transform', `translate(${padding.left} ${padding.top})`);

								// add in axis groups
								const xAxisG = g.append('g').classed('x-axis', true)
									.attr('transform', `translate(0 ${plotAreaHeight + pointRadius})`);

								// x-axis label
								g.append('text')
									.attr('transform', `translate(${plotAreaWidth / 2} ${plotAreaHeight + (padding.bottom)})`)
									.attr('dy', -4) // adjust distance from the bottom edge
									.attr('class', 'axis-label')
									.attr('text-anchor', 'middle')
									.text('X Axis');

								const yAxisG = g.append('g').classed('y-axis', true)
									.attr('transform', `translate(${-pointRadius} 0)`);

								// y-axis label
								g.append('text')
									.attr('transform', `rotate(270) translate(${-plotAreaHeight / 2} ${-padding.left})`)
									.attr('dy', 12) // adjust distance from the left edge
									.attr('class', 'axis-label')
									.attr('text-anchor', 'middle')
									.text('Y Axis');

								// set up axis generating functions
								const xTicks = Math.round(plotAreaWidth / 50);
								const yTicks = Math.round(plotAreaHeight / 50);

								const xAxis = d3.axisBottom(xScale)
									.ticks(xTicks)
									.tickSizeOuter(0);

								const yAxis = d3.axisLeft(yScale)
									.ticks(yTicks)
									.tickSizeOuter(0);

								// draw the axes
								yAxisG.call(yAxis);
								xAxisG.call(xAxis);


								// add in circles
								const circles = g.append('g').attr('class', 'circles');
								const binding = circles.selectAll('.data-point').data(data, d => d.id);
								binding.enter().append('circle')
									.classed('data-point', true)
									.attr('r', pointRadius)
									.attr('cx', d => xScale(d.x))
									.attr('cy', d => yScale(d.y))
									.attr('fill', d => colorScale(d.y));


								// ----------------------------------------------------
								// Add in Voronoi interaction
								// ----------------------------------------------------

								// add in interaction via voronoi
								// initialize text output for highlighted points
								const highlightOutput = container.append('div')
									.attr('class', 'highlight-output')
									.style('padding-left', `${padding.left}px`)
									.style('min-height', '100px');

								// create a voronoi diagram based on the data and the scales
								const voronoiDiagram = d3.voronoi()
									.x(d => xScale(d.x))
									.y(d => yScale(d.y))
									.size([plotAreaWidth, plotAreaHeight])(data);

								// limit how far away the mouse can be from finding a voronoi site
								const voronoiRadius = plotAreaWidth / 10;


								// add a circle for indicating the highlighted point
								g.append('circle')
									.attr('class', 'highlight-circle')
									.attr('r', pointRadius + 2) // slightly larger than our points
									.style('fill', 'none')
									.style('display', 'none');

								// callback to highlight a point
								function highlight(d) {
									// no point to highlight - hide the circle and clear the text
									if (!d) {
										d3.select('.highlight-circle').style('display', 'none');
										highlightOutput.text('');

									// otherwise, show the highlight circle at the correct position
									} else {
										d3.select('.highlight-circle')
											.style('display', '')
											.style('stroke', colorScale(d.y))
											.attr('cx', xScale(d.x))
											.attr('cy', yScale(d.y));

										// format the highlighted data point for inspection
										highlightOutput.html(JSON.stringify(d)
											.replace(/([{}])/g, '')
											.replace(/"(.+?)":/g, '<strong style="width: 40px; display: inline-block">$1:</strong> ')
											.replace(/,/g, '<br>'));
									}
								}

								// callback for when the mouse moves across the overlay
								function mouseMoveHandler() {
									// get the current mouse position
									const [mx, my] = d3.mouse(this);

									// use the new diagram.find() function to find the voronoi site closest to
									// the mouse, limited by max distance defined by voronoiRadius
									const site = voronoiDiagram.find(mx, my, voronoiRadius);

									// highlight the point if we found one, otherwise hide the highlight circle
									highlight(site && site.data);
								}

								// add the overlay on top of everything to take the mouse events
								g.append('rect')
									.attr('class', 'overlay')
									.attr('width', plotAreaWidth)
									.attr('height', plotAreaHeight)
									.style('fill', 'red')
									.style('opacity', 0)
									.on('mousemove', mouseMoveHandler)
									.on('mouseleave', () => {
										// hide the highlight circle when the mouse leaves the chart
										highlight(null);
									});

								// ----------------------------------------------------
								// Add a fun click handler to reveal the details of what is happening
								// ----------------------------------------------------

								/**
								 * Add/remove a visible voronoi diagram and a circle indicating the radius used
								 * in the voronoi find function
								 */
								function toggleVoronoiDebug() {
									// remove if there
									if (!g.select('.voronoi-polygons').empty()) {
										g.select('.voronoi-polygons').remove();
										g.select('.voronoi-radius-circle').remove();
										g.select('.overlay').on('mousemove.voronoi', null).on('mouseleave.voronoi', null);
									// otherwise, add the polygons in
									} else {
										// add a circle to follow the mouse to draw the voronoi radius
										g.append('circle')
											.attr('class', 'voronoi-radius-circle')
											.attr('r', voronoiRadius)
											.style('fill', 'none')
											.style('stroke', 'tomato')
											.style('stroke-dasharray', '3,2')
											.style('display', 'none');


										// move the voronoi radius mouse circle with the mouse
										g.select('.overlay')
											.on('mousemove.voronoi', function mouseMoveVoronoiHandler() {
												const [mx, my] = d3.mouse(this);
												d3.select('.voronoi-radius-circle')
													.style('display', '')
													.attr('cx', mx)
													.attr('cy', my);
											})
											.on('mouseleave.voronoi', () => {
												d3.select('.voronoi-radius-circle').style('display', 'none');
											});


										// draw the polygons
										const voronoiPolygons = g.append('g')
											.attr('class', 'voronoi-polygons')
											.style('pointer-events', 'none');

										const binding = voronoiPolygons.selectAll('path').data(voronoiDiagram.polygons());
										binding.enter().append('path')
											.style('stroke', 'tomato')
											.style('fill', 'none')
											.style('opacity', 0.15)
											.attr('d', d => `M${d.join('L')}Z`);
									}
								}

								// turn on and off voronoi debugging with click
								svg.on('click', toggleVoronoiDebug);
            }

          // ############# parallel axes ###############
          if (chartType === 'parallel-axes') {
            var margin = {top: 66, right: 110, bottom: 20, left: 188},
                width = document.body.clientWidth - margin.left - margin.right,
                height = 340 - margin.top - margin.bottom,
                innerHeight = height - 2;

            var devicePixelRatio = window.devicePixelRatio || 1;

            var color = d3.scaleOrdinal()
              .range(["#5DA5B3","#D58323","#DD6CA7","#54AF52","#8C92E8","#E15E5A","#725D82","#776327","#50AB84","#954D56","#AB9C27","#517C3F","#9D5130","#357468","#5E9ACF","#C47DCB","#7D9E33","#DB7F85","#BA89AD","#4C6C86","#B59248","#D8597D","#944F7E","#D67D4B","#8F86C2"]);

            var types = {
              "Number": {
                key: "Number",
                coerce: function(d) { return +d; },
                extent: d3.extent,
                within: function(d, extent, dim) { return extent[0] <= dim.scale(d) && dim.scale(d) <= extent[1]; },
                defaultScale: d3.scaleLinear().range([innerHeight, 0])
              },
              "String": {
                key: "String",
                coerce: String,
                extent: function (data) { return data.sort(); },
                within: function(d, extent, dim) { return extent[0] <= dim.scale(d) && dim.scale(d) <= extent[1]; },
                defaultScale: d3.scalePoint().range([0, innerHeight])
              },
              "Date": {
                key: "Date",
                coerce: function(d) { return new Date(d); },
                extent: d3.extent,
                within: function(d, extent, dim) { return extent[0] <= dim.scale(d) && dim.scale(d) <= extent[1]; },
                defaultScale: d3.scaleTime().range([0, innerHeight])
              }
            };

            var dimensions = [
              {
                key: "food_group",
                description: "Food Group",
                type: types["String"],
                axis: d3.axisLeft()
                  .tickFormat(function(d,i) {
                    return d;
                  })
              },
              {
                key: "Total lipid (fat) (g)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Sugars, total (g)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Calcium, Ca (mg)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Sodium, Na (mg)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Phosphorus, P (mg)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Potassium, K (mg)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Thiamin (mg)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Riboflavin (mg)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Niacin (mg)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Iron, Fe (mg)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Magnesium, Mg (mg)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Protein (g)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Zinc, Zn (mg)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Vitamin B-6 (mg)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Vitamin B-12 (mcg)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Folic acid (mcg)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Selenium, Se (mcg)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Vitamin A, IU (IU)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Vitamin K (phylloquinone) (mcg)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Vitamin C, total ascorbic acid (mg)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Vitamin D (IU)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Cholesterol (mg)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Fiber, total dietary (g)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "Carbohydrate, by difference (g)",
                type: types["Number"],
                scale: d3.scaleSqrt().range([innerHeight, 0])
              },
              {
                key: "manufac_name",
                description: "Manufacturer", 
                type: types["String"],
                axis: d3.axisRight()
                  .tickFormat(function(d,i) {
                    if (d == null) return "(null)";
                    return i % 5 == 0 ? d.slice(0,22) : "";
                  })
              }
            ];

            var xscale = d3.scalePoint()
                .domain(d3.range(dimensions.length))
                .range([0, width]);

            var yAxis = d3.axisLeft();

            var container = d3.select("#vis-container").append("div")
                .attr("class", "parcoords")
                .style("width", width + margin.left + margin.right + "px")
                .style("height", height + margin.top + margin.bottom + "px");

            var svg = container.append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
              .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            var canvas = container.append("canvas")
                .attr("width", width * devicePixelRatio)
                .attr("height", height * devicePixelRatio)
                .style("width", width + "px")
                .style("height", height + "px")
                .style("margin-top", margin.top + "px")
                .style("margin-left", margin.left + "px");

            var ctx = canvas.node().getContext("2d");
            ctx.globalCompositeOperation = 'darken';
            ctx.globalAlpha = 0.15;
            ctx.lineWidth = 1.5;
            ctx.scale(devicePixelRatio, devicePixelRatio);

            var output = d3.select("#vis-container").append("pre");

            var axes = svg.selectAll(".axis")
                .data(dimensions)
              .enter().append("g")
                .attr("class", function(d) { return "axis " + d.key.replace(/ /g, "_"); })
                .attr("transform", function(d,i) { return "translate(" + xscale(i) + ")"; });

            d3.csv("nutrient.csv", function(error, data) {
              if (error) throw error;

              // shuffle the data!
              data = d3.shuffle(data);

              data.forEach(function(d) {
                dimensions.forEach(function(p) {
                  d[p.key] = !d[p.key] ? null : p.type.coerce(d[p.key]);
                });

                // truncate long text strings to fit in data table
                for (var key in d) {
                  if (d[key] && d[key].length > 35) d[key] = d[key].slice(0,36);
                }
              });

              // type/dimension default setting happens here
              dimensions.forEach(function(dim) {
                if (!("domain" in dim)) {
                  // detect domain using dimension type's extent function
                  dim.domain = d3_functor(dim.type.extent)(data.map(function(d) { return d[dim.key]; }));
                }
                if (!("scale" in dim)) {
                  // use type's default scale for dimension
                  dim.scale = dim.type.defaultScale.copy();
                }
                dim.scale.domain(dim.domain);
              });

              var render = renderQueue(draw).rate(50);

              ctx.clearRect(0,0,width,height);
              ctx.globalAlpha = d3.min([0.85/Math.pow(data.length,0.3),1]);
              render(data);

              axes.append("g")
                  .each(function(d) {
                    var renderAxis = "axis" in d
                      ? d.axis.scale(d.scale)  // custom axis
                      : yAxis.scale(d.scale);  // default axis
                    d3.select(this).call(renderAxis);
                  })
                .append("text")
                  .attr("class", "title")
                  .attr("text-anchor", "start")
                  .text(function(d) { return "description" in d ? d.description : d.key; });

              // Add and store a brush for each axis.
              axes.append("g")
                  .attr("class", "brush")
                  .each(function(d) {
                    d3.select(this).call(d.brush = d3.brushY()
                      .extent([[-10,0], [10,height]])
                      .on("start", brushstart)
                      .on("brush", brush)
                      .on("end", brush)
                    )
                  })
                .selectAll("rect")
                  .attr("x", -8)
                  .attr("width", 16);

              d3.selectAll(".axis.food_group .tick text")
                .style("fill", color);
                
              output.text(d3.tsvFormat(data.slice(0,24)));

              function project(d) {
                return dimensions.map(function(p,i) {
                  // check if data element has property and contains a value
                  if (
                    !(p.key in d) ||
                    d[p.key] === null
                  ) return null;

                  return [xscale(i),p.scale(d[p.key])];
                });
              };

              function draw(d) {
                ctx.strokeStyle = color(d.food_group);
                ctx.beginPath();
                var coords = project(d);
                coords.forEach(function(p,i) {
                  // this tricky bit avoids rendering null values as 0
                  if (p === null) {
                    // this bit renders horizontal lines on the previous/next
                    // dimensions, so that sandwiched null values are visible
                    if (i > 0) {
                      var prev = coords[i-1];
                      if (prev !== null) {
                        ctx.moveTo(prev[0],prev[1]);
                        ctx.lineTo(prev[0]+6,prev[1]);
                      }
                    }
                    if (i < coords.length-1) {
                      var next = coords[i+1];
                      if (next !== null) {
                        ctx.moveTo(next[0]-6,next[1]);
                      }
                    }
                    return;
                  }
                  
                  if (i == 0) {
                    ctx.moveTo(p[0],p[1]);
                    return;
                  }

                  ctx.lineTo(p[0],p[1]);
                });
                ctx.stroke();
              }

              function brushstart() {
                d3.event.sourceEvent.stopPropagation();
              }

              // Handles a brush event, toggling the display of foreground lines.
              function brush() {
                render.invalidate();

                var actives = [];
                svg.selectAll(".axis .brush")
                  .filter(function(d) {
                    return d3.brushSelection(this);
                  })
                  .each(function(d) {
                    actives.push({
                      dimension: d,
                      extent: d3.brushSelection(this)
                    });
                  });

                var selected = data.filter(function(d) {
                  if (actives.every(function(active) {
                      var dim = active.dimension;
                      // test if point is within extents for each active brush
                      return dim.type.within(d[dim.key], active.extent, dim);
                    })) {
                    return true;
                  }
                });

                // show ticks for active brush dimensions
                // and filter ticks to only those within brush extents
                /*
                svg.selectAll(".axis")
                    .filter(function(d) {
                      return actives.indexOf(d) > -1 ? true : false;
                    })
                    .classed("active", true)
                    .each(function(dimension, i) {
                      var extent = extents[i];
                      d3.select(this)
                        .selectAll(".tick text")
                        .style("display", function(d) {
                          var value = dimension.type.coerce(d);
                          return dimension.type.within(value, extent, dimension) ? null : "none";
                        });
                    });

                // reset dimensions without active brushes
                svg.selectAll(".axis")
                    .filter(function(d) {
                      return actives.indexOf(d) > -1 ? false : true;
                    })
                    .classed("active", false)
                    .selectAll(".tick text")
                      .style("display", null);
                */

                ctx.clearRect(0,0,width,height);
                ctx.globalAlpha = d3.min([0.85/Math.pow(selected.length,0.3),1]);
                render(selected);

                output.text(d3.tsvFormat(selected.slice(0,24)));
              }
            });

            function d3_functor(v) {
              return typeof v === "function" ? v : function() { return v; };
            };
    
          }
        }
        </script>
    </body>
</html>
